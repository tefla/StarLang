# Pong - Forge 2.0
# A clean implementation of Pong demonstrating the language

# =============================================================================
# Game Configuration
# =============================================================================

let config = {
  arena_width: 20,
  arena_depth: 12,
  paddle_speed: 8,
  paddle_height: 2.5,
  ball_max_speed: 15,
  win_score: 5
}

# =============================================================================
# Game State
# =============================================================================

let ball = {
  x: 0,
  y: 0.25,
  z: 0,
  vx: 5,
  vz: 3
}

let paddle_left = {
  x: -9,
  y: 0.25,
  z: 0
}

let paddle_right = {
  x: 9,
  y: 0.25,
  z: 0
}

let score = {
  left: 0,
  right: 0
}

let game = {
  active: false,
  paused: false,
  started: false
}

# =============================================================================
# Visual Meshes (created in init)
# =============================================================================

let ball_mesh = null
let paddle_left_mesh = null
let paddle_right_mesh = null
let floor_mesh = null
let wall_top_mesh = null
let wall_bottom_mesh = null

# =============================================================================
# UI Elements (created in init)
# =============================================================================

let ui_score = null
let ui_start_screen = null
let ui_gameover_screen = null
let ui_gameover_text = null
let ui_pause_text = null

# =============================================================================
# Helper Functions
# =============================================================================

fn clamp_paddle(z):
  let limit = config.arena_depth / 2 - 1.5
  return math.clamp(z, -limit, limit)

fn clamp_ball_speed(v):
  return math.clamp(v, -config.ball_max_speed, config.ball_max_speed)

fn reset_ball(direction):
  set ball.x: 0
  set ball.z: 0
  set ball.vx: direction * 5
  set ball.vz: (random.float(-1, 1)) * 3
  set paddle_left.z: 0
  set paddle_right.z: 0

# =============================================================================
# Ball Physics
# =============================================================================

on "tick" when game.active and not game.paused:
  let dt = event.dt

  # Move ball
  set ball.x: ball.x + ball.vx * dt
  set ball.z: ball.z + ball.vz * dt

# Wall bounces
on "tick" when ball.z < -config.arena_depth / 2 + 0.3 and ball.vz < 0:
  set ball.vz: abs(ball.vz)
  emit "sound:bounce"

on "tick" when ball.z > config.arena_depth / 2 - 0.3 and ball.vz > 0:
  set ball.vz: -abs(ball.vz)
  emit "sound:bounce"

# =============================================================================
# Paddle Collision
# =============================================================================

# Left paddle hit
on "tick" when ball.x < -8.5 and ball.x > -9.5 and ball.vx < 0:
  if abs(ball.z - paddle_left.z) < 1.5:
    set ball.vx: clamp_ball_speed(abs(ball.vx) * 1.05)
    set ball.vz: clamp_ball_speed(ball.vz + (ball.z - paddle_left.z) * 2)
    emit "sound:hit"

# Right paddle hit
on "tick" when ball.x > 8.5 and ball.x < 9.5 and ball.vx > 0:
  if abs(ball.z - paddle_right.z) < 1.5:
    set ball.vx: clamp_ball_speed(-abs(ball.vx) * 1.05)
    set ball.vz: clamp_ball_speed(ball.vz + (ball.z - paddle_right.z) * 2)
    emit "sound:hit"

# =============================================================================
# Player Input (Left Paddle)
# =============================================================================

on "tick" when game.active and (input.isKeyDown("W") or input.isKeyDown("ArrowUp")):
  set paddle_left.z: clamp_paddle(paddle_left.z - config.paddle_speed * event.dt)

on "tick" when game.active and (input.isKeyDown("S") or input.isKeyDown("ArrowDown")):
  set paddle_left.z: clamp_paddle(paddle_left.z + config.paddle_speed * event.dt)

# =============================================================================
# AI Control (Right Paddle)
# =============================================================================

on "tick" when game.active:
  let dt = event.dt

  # AI tracks ball when it's coming towards it, returns to center otherwise
  if ball.vx > 0:
    set paddle_right.z: math.lerp(paddle_right.z, ball.z, 3 * dt)
  else:
    set paddle_right.z: math.lerp(paddle_right.z, 0, 1 * dt)

  set paddle_right.z: clamp_paddle(paddle_right.z)

# =============================================================================
# Scoring
# =============================================================================

# Right scores (ball passed left boundary)
on "tick" when ball.x < -config.arena_width / 2 - 0.5:
  set score.right: score.right + 1
  ui.setText(ui_score, score.left + " - " + score.right)
  emit "sound:score"
  emit "ui:score_update" { left: score.left, right: score.right }
  reset_ball(-1)  # Serve towards loser

# Left scores (ball passed right boundary)
on "tick" when ball.x > config.arena_width / 2 + 0.5:
  set score.left: score.left + 1
  ui.setText(ui_score, score.left + " - " + score.right)
  emit "sound:score"
  emit "ui:score_update" { left: score.left, right: score.right }
  reset_ball(1)  # Serve towards loser

# =============================================================================
# Victory Conditions
# =============================================================================

on "tick" when score.left >= config.win_score and game.active:
  set game.active: false
  ui.setText(ui_gameover_text, "YOU WIN!")
  ui.setStyle(ui_gameover_text, "color", "#00ff88")
  ui.show(ui_gameover_screen)
  emit "sound:victory"
  emit "game:victory" { winner: "player", message: "YOU WIN!" }

on "tick" when score.right >= config.win_score and game.active:
  set game.active: false
  ui.setText(ui_gameover_text, "AI WINS!")
  ui.setStyle(ui_gameover_text, "color", "#ff4466")
  ui.show(ui_gameover_screen)
  emit "sound:defeat"
  emit "game:defeat" { winner: "ai", message: "AI WINS!" }

# =============================================================================
# Game Controls
# =============================================================================

on "keydown:Escape" when game.started:
  set game.paused: not game.paused
  if game.paused:
    ui.show(ui_pause_text)
  else:
    ui.hide(ui_pause_text)

on "keydown: " when not game.started:
  # Space to start game from start screen
  ui.hide(ui_start_screen)
  set game.started: true
  set game.active: true
  reset_ball(1)

on "keydown:R" when game.started and not game.active:
  # Restart game after game over
  ui.hide(ui_gameover_screen)
  set score.left: 0
  set score.right: 0
  set game.active: true
  set game.paused: false
  reset_ball(1)
  ui.setText(ui_score, "0 - 0")
  emit "game:restart"

# =============================================================================
# Initialization
# =============================================================================

on "init":
  # Create arena floor
  set floor_mesh: render.box(config.arena_width + 2, 0.1, config.arena_depth + 2, "#1a1a2e")
  render.spawn(floor_mesh)
  render.setPosition(floor_mesh, 0, -0.05, 0)

  # Create top and bottom walls
  set wall_top_mesh: render.box(config.arena_width + 2, 0.3, 0.3, "#3a3a5e")
  render.spawn(wall_top_mesh)
  render.setPosition(wall_top_mesh, 0, 0.15, -config.arena_depth / 2 - 0.15)

  set wall_bottom_mesh: render.box(config.arena_width + 2, 0.3, 0.3, "#3a3a5e")
  render.spawn(wall_bottom_mesh)
  render.setPosition(wall_bottom_mesh, 0, 0.15, config.arena_depth / 2 + 0.15)

  # Create ball (white sphere)
  set ball_mesh: render.sphere(0.35, "#ffffff")
  render.spawn(ball_mesh)
  render.setEmissive(ball_mesh, "#ffffff", 0.3)

  # Create left paddle (player - green)
  set paddle_left_mesh: render.box(0.3, 0.5, config.paddle_height, "#00ff88")
  render.spawn(paddle_left_mesh)
  render.setEmissive(paddle_left_mesh, "#00ff88", 0.3)

  # Create right paddle (AI - red)
  set paddle_right_mesh: render.box(0.3, 0.5, config.paddle_height, "#ff4466")
  render.spawn(paddle_right_mesh)
  render.setEmissive(paddle_right_mesh, "#ff4466", 0.3)

  # Center line (decorative)
  let center_line = render.box(0.05, 0.02, config.arena_depth, "#444466")
  render.spawn(center_line)
  render.setPosition(center_line, 0, 0.01, 0)

  # =========================================================================
  # UI Setup
  # =========================================================================

  # Score display (always visible during game)
  set ui_score: ui.text("0 - 0", {
    anchor: "top-center",
    y: 30,
    fontSize: 36,
    color: "#ffffff"
  })

  # Pause text (hidden by default)
  set ui_pause_text: ui.text("PAUSED", {
    anchor: "center",
    fontSize: 48,
    color: "#ffcc00"
  })
  ui.hide(ui_pause_text)

  # Start screen
  set ui_start_screen: ui.screen("start", { background: "rgba(0, 0, 0, 0.85)" })
  let title = ui.text("PONG", { fontSize: 72, color: "#00ff88" })
  let subtitle = ui.text("W/S or Arrow Keys to move paddle", { fontSize: 18, color: "#888888" })
  let start_hint = ui.text("Press SPACE to Start", { fontSize: 24, color: "#ffffff" })
  let win_info = ui.text("First to 5 wins!", { fontSize: 16, color: "#666666" })
  ui.add(ui_start_screen, title)
  ui.add(ui_start_screen, subtitle)
  ui.add(ui_start_screen, start_hint)
  ui.add(ui_start_screen, win_info)
  ui.show(ui_start_screen)

  # Game over screen
  set ui_gameover_screen: ui.screen("gameover", { background: "rgba(0, 0, 0, 0.9)" })
  set ui_gameover_text: ui.text("GAME OVER", { fontSize: 56, color: "#ff4466" })
  let restart_hint = ui.text("Press R to Restart", { fontSize: 20, color: "#888888" })
  ui.add(ui_gameover_screen, ui_gameover_text)
  ui.add(ui_gameover_screen, restart_hint)

  emit "game:ready" {
    title: "PONG",
    instructions: "W/S or Arrow Keys to move. First to 5 wins!"
  }

# =============================================================================
# Visual Sync (update mesh positions from state)
# =============================================================================

on "tick":
  # Update ball position
  if ball_mesh != null:
    render.setPosition(ball_mesh, ball.x, ball.y, ball.z)

  # Update paddle positions
  if paddle_left_mesh != null:
    render.setPosition(paddle_left_mesh, paddle_left.x, paddle_left.y, paddle_left.z)

  if paddle_right_mesh != null:
    render.setPosition(paddle_right_mesh, paddle_right.x, paddle_right.y, paddle_right.z)
